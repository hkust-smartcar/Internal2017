/*
 * main.cpp
 *
 * Author: Peter
 * Copyright (c) 2014-2015 HKUST SmartCar Team
 * Refer to LICENSE for details
 */

#include <cassert>
#include <cstring>
#include <libbase/k60/mcg.h>
#include <libsc/system.h>
//#include <libsc/led.h>
//#include <libsc/button.h>
#include <libsc/k60/ov7725.h>
#include <libsc/k60/ov7725_configurator.h>
#include <libsc/lcd.h>
#include <libsc/st7735r.h>
#include <libsc/system.h>
#include <libsc/config.h>
#include <libsc/servo.h>
#include <libsc/motor.h>
#include <libsc/lcd_typewriter.h>
#include <libsc/tower_pro_mg995.h>
#include <libsc/k60/jy_mcu_bt_106.h>
//#include <libutil>
//#include <libsc/config.h>


namespace libbase
{
	namespace k60
	{

		Mcg::Config Mcg::GetMcgConfig()
		{
			Mcg::Config config;
			config.external_oscillator_khz = 50000;
			config.core_clock_khz = 150000;
			return config;
		}

	}
}

using namespace libsc;
//using namespace libbase::k60;
using namespace k60;

struct circle
{
	int x;
	int y;
	int distance;
};

circle circle_detection(int image[80][60], int length, int width);


int image[80][60];
bool procArray[80];
Byte* track;

int height = 60;
int camera_width = 80;

//void imageInit();
//void extractArray(int row);
void getImage(Byte * data);


int main(void)
{
	// system init-----------------------------------------
	System::Init();

	// lcd init-----------------------------------------

	St7735r::Config st;
	st.fps = 100;
	St7735r lcd1(st);

	LcdTypewriter::Config config;
	config.lcd = &lcd1; // St7735r lcd from prev page
	LcdTypewriter writer(config);

	// camera init-----------------------------------------
	Ov7725::Config ov;
	ov.id = 0;
	ov.w = 80;
	ov.h = 60;
	ov.fps = Ov7725::Config::Fps::kMid;	//100

	Ov7725 cam1(ov);

	JyMcuBt106::Config blth;
	blth.id = 0;
	blth.baud_rate = libbase::k60::Uart::Config::BaudRate::k115200;
//	blth.rx_isr = bluetoothFunc;

	JyMcuBt106 bt1(blth);

//	TowerProMg995::Config se;

	cam1.Start();

	circle test;
	char buf[50];


	while (true)
	{
		if (System::Time() %50 == 0)
		{
	//		lcd1.Clear(0);
			lcd1.SetRegion(Lcd::Rect(0,0,80,60));
			// Collect camera input & print it on LCD-----------------------------------------
					track = (Byte*) cam1.LockBuffer();
					lcd1.FillBits(lcd1.kBlack, lcd1.kWhite, track, cam1.GetBufferSize()*8);
			// Signal proc. : Byte to 2D array -----------------------------------------
					getImage(track);
	//				camera1.UnlockBuffer();
//			lcd1.FillBits(lcd1.kBlack, lcd1.kWhite, cam1.LockBuffer(), cam1.GetBufferSize()*8);	//8
			cam1.UnlockBuffer();

			test = circle_detection(image,80,60);

			if (test.distance != 0)
			{
			lcd1.SetRegion(Lcd::Rect(10,90,80,30));
	//		writer.WriteString("X/ Y/ Dist");
			sprintf(buf,"X=  %d", test.x);
			writer.WriteString(buf);

			lcd1.SetRegion(Lcd::Rect(10,105,80,30));
	//		writer.WriteString(buf);
			sprintf(buf,"Y=  %d", test.y);
	//		lcd1.SetRegion(Lcd::Rect(10,100,80,60));
			writer.WriteString(buf);

			lcd1.SetRegion(Lcd::Rect(10,120,80,30));
			sprintf(buf,"Dist=  %d", test.distance);
			writer.WriteString(buf);

			lcd1.SetRegion(Lcd::Rect(test.x, test.y, test.distance, test.distance));
			lcd1.FillColor(0x001F);
			}

		}
	}

	return 0;
}



void getImage(Byte * data)
{
	int pos = 0, bit_pos = 8;

	for (int y = 0; y < height; y++)
	{
		for (int x = 0; x < camera_width; x++)
		{
			if (--bit_pos < 0)
			{
				bit_pos = 7;
				++pos;
			}
			if (GET_BIT(data[pos], bit_pos))
			{	image[x][y] = 1;	}		//
			else
			{	image[x][y] = 0;	}		//
		}
	}
}

circle circle_detection(int image[80][60], int length, int width)
{
//	bool found = false;
//	int sCount = 1;

	circle sphere;
	sphere.distance = 0;
	sphere.x = 0;
	sphere.y = 0;
/*
	sphere[2].distance = 0;
	sphere[2].x = 0;
	sphere[2].y = 0;
*/	int count = 0;
	int x_temp = 0;
	int y_temp = 0;
//	int x_match = 0;
	int y_match = 0;
	int x_check = 0;
	int y_check = 0;

//	if (found != false){
	for (int y = 0; y < width; y++)
		for (int x = 0; x < length; x++)
		{
			if (image[x][y] == 0)					// find dark pixel from 2d image
			{										//1
				if (count == 0)
				{	x_temp = x;
					y_temp = y;}
				count++;
			}
			else									// a circle must able to form a square inside
			{
				if ( count > 2)						// ignore a dot
				{
					for (int j = y_temp; j < width ; j++)
					{
							if (image[x_temp][j] == 0)			//1
							{	y_match++;	}
							else break;
					}
					if (y_match == count)// && (image[(x_temp +count -2)][(y_temp +count -2)] == 1))				// if x = y, it is a square/circle
					{
						x_check = x_temp +count-1;
						y_check = y_temp +count-1;

		//				cout << x_check << "   " << y_check << endl;
		//				cout << image[x_check][y_check]<< endl;
						if (image[x_check][y_check]== 0)		//1
						{
							sphere.x = x_temp;			// start pt. of x
							sphere.y = y_temp;			// start pt. of y
							sphere.distance = count;
					//	sCount++;
				//		found = true;
				//		break;
						}
					}
				}
				count = 0;
				y_match = 0;
			}
	}
	return sphere;
}

