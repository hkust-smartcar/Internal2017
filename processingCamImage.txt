/*

//plase include the following code in you smartcar program

//include bluetooth
#include <libsc/k60/jy_mcu_bt_106.h>

//initialize
JyMcuBt106::Config BluetoothConfig;
BluetoothConfig.id = 0;
BluetoothConfig.baud_rate = libbase::k60::Uart::Config::BaudRate::k115200;
JyMcuBt106 bluetooth1(BluetoothConfig);

//starting signal telling processing to start receiving the image
//please help me to improve this method...^,^
const Byte imageByte = 170;
const Byte * imageBytePtr = &imageByte;

//in the main loop
bluetooth1.SendBuffer(imageBytePtr, 1);
bluetooth1.SendBuffer(camInput, Cam1.GetBufferSize());

*/

import processing.serial.*;
import java.util.*;

Serial myPort;
BufferedReader reader;
PrintWriter writer;

int globalWidth = 80;
int globalHeight = 60;
int arrayPosX, arrayPosY;

Boolean overviewMode = true;

int pixelSide = 4;
Boolean[][] pixelArray = new Boolean[globalHeight][globalWidth];
int imageX = 10, imageY = 10;

Boolean[][] boundaryArray = new Boolean[globalHeight][globalWidth];
int boundaryX = 710, boundaryY = 10;

int regionSide = 5;
int regionSize = (globalHeight*globalWidth) / (regionSide*regionSide);
int[] regionArray = new int[regionSize];
int regionX = 360, regionY = 10;

int inputValue;
double[] leftSpeedValue, rightSpeedValue;
double leftSpeed = 0, rightSpeed = 0;

int graphLength = 800;
int graphWidth = 400, graphHeight = 250;
int graphOneX = 100, graphOneY = 300;
int graphTwoX = 600, graphTwoY = 300;

int diameter = 50;
int leftX = 100, leftY = 600;
int middleX = 200, middleY = 600;
int rightX = 300, rightY = 600;
boolean leftOver = false;
boolean middleOver = false;
boolean rightOver = false;

int modeButtonX = 1100, modeButtonY = 60;
boolean modeButtonOver = false;


int leftData[][] = {

  {0, 0, 0, 0, 0, 2, 4, 8, 10, 10, 10, 10, 10, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 2, 7, 10, 10, 10, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 8, 10, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  ,
  {0, 0, 0, 0, 0, 0, 2, 4, 8, 10, 10, 10, 10, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 5, 9, 10, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

};
int middleData[][] = {

  {10, 10, 10, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 10, 10, 10, 10, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 10, 10, 10, 10, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 10, 10, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 10, 10, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 10, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  ,
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 10, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 10, 10, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 10, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  ,
  {10, 10, 10, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 10, 10, 10, 10, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 10, 10, 8, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

};
int rightData[][] = {

  {10, 10, 10, 10, 10, 8, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 10, 8, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 9, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 10, 10}
  ,
  {10, 10, 10, 10, 10, 10, 10, 8, 4, 1, 0, 0, 0, 0, 0, 0, 10, 10, 10, 10, 10, 8, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 10, 10, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

};

void getImage(int data) {

  String binData = "";
  int strLen = 0;
  
  binData = Integer.toBinaryString(data);
  strLen = binData.length();
  //println(binData);
  
  for (int i=0; i<8; i++) {
    
    if (i < strLen) {
      
      if (binData.charAt(strLen-1-i) == '1') {
        pixelArray[arrayPosY][arrayPosX+7-i] = true;
      } else {
        pixelArray[arrayPosY][arrayPosX+7-i] = false;
      }
      
    } else {
      pixelArray[arrayPosY][arrayPosX+7-i] = false;
    }
    
  }
  
  arrayPosX += 8;
  
  if (arrayPosX >= globalWidth) {
    arrayPosX = 0;
    arrayPosY++;
  }
  if (arrayPosY >= globalHeight) {
    arrayPosY = 0;
  }

}

void outputImage() {
  
  for (int y=0; y<globalHeight; y++) {
    for (int x=0; x<globalWidth; x++) {
      if (pixelArray[y][x]) {
        fill(0);
      } else {
        fill(255);
      }
      noStroke();
      rect(imageX + pixelSide*x, imageY + pixelSide*y, pixelSide, pixelSide);
    }
  }
  
}

void getBoundary() {
  
  Boolean previous;
  
  for (int y = 0; y < globalHeight; y++) {

    previous = pixelArray[y][0];

    for (int x = 0; x < globalWidth; x++) {

      if (pixelArray[y][x] != previous) {

        if (pixelArray[y][x] == false) {
          boundaryArray[y][x] = true;
        } else {
          boundaryArray[y][x-1] = true;
          boundaryArray[y][x] = false;
        }
        previous = pixelArray[y][x];

      } else {
        boundaryArray[y][x] = false;
      }

    }

  }

  for (int x = 0; x < globalWidth; x++) {

    previous = pixelArray[0][x];

    for (int y = 0; y < globalHeight; y++) {

      if (pixelArray[y][x] != previous) {

        if (pixelArray[y][x] == false) {
          boundaryArray[y][x] = true;
        } else {
          boundaryArray[y-1][x] = true;
          boundaryArray[y][x] = false;
        }
        previous = pixelArray[y][x];

      }

    }

  }
  
}

void outputBoundary() {
  
  for (int y=0; y<globalHeight; y++) {
    for (int x=0; x<globalWidth; x++) {
      if (boundaryArray[y][x]) {
        fill(0);
      } else {
        fill(255);
      }
      noStroke();
      rect(boundaryX + pixelSide*x, boundaryY + pixelSide*y, pixelSide, pixelSide);
    }
  }
  
}

void getRegion() {
  
  int counter = 0;
  
  for (int y=0; y<globalHeight; y+=regionSide) {
    for (int x=0; x<globalWidth; x+=regionSide) {
      
      int sum = 0;
      
      for (int subY=0; subY<regionSide; subY++) {
        for (int subX=0; subX<regionSide; subX++) {
          
          if (pixelArray[y+subY][x+subX]) {
            sum++;
          }
          
        }
      }
      
      regionArray[counter] = sum*10/(regionSide*regionSide);
      counter++;
      
    }
  }
  
}

void outputRegion() {
  
  int x, y;
  
  for (int i=0; i<regionSize; i++) {
    
    x = i % (globalWidth/regionSide);
    y = i / (globalWidth/regionSide);
    
    fill((int)((1 - ((double)regionArray[i]/10)) * 255));
    noStroke();
    rect(regionX + regionSide*pixelSide*x, regionY + regionSide*pixelSide*y,
    regionSide*pixelSide, regionSide*pixelSide);
    
  }
  
}

int compareRegion(int data[][]) {

  int totalDifference = 0, minDifference = 10000;

  for (int i=0; i<data.length; i++) {

    totalDifference = 0;

    for (int j=0; j<data[i].length;j++) {

      int difference = data[i][j] - regionArray[j];

      if (difference > 0) {
        totalDifference += difference;
      } else {
        totalDifference -= difference;
      }

    }

    if (totalDifference < minDifference) {
      minDifference = totalDifference;
    }

  }

  return minDifference;

}

void turningResult() {
      
  int leftMin = compareRegion(leftData);
  int middleMin = compareRegion(middleData);
  int rightMin = compareRegion(rightData);
  
  fill(0);
  ellipse(leftX, leftY, diameter, diameter);
  ellipse(middleX, middleY, diameter, diameter);
  ellipse(rightX, rightY, diameter, diameter);
  
  if (leftMin<middleMin && leftMin<rightMin) {
    fill(255);
    ellipse(leftX, leftY, diameter, diameter);
  } else if (rightMin<middleMin && rightMin<leftMin) {
    fill(255);
    ellipse(rightX, rightY, diameter, diameter);
  } else {
    fill(255);
    ellipse(middleX, middleY, diameter, diameter);
  }

}

void plotGraph() {
  
  fill(#404040);
  stroke(0);
  rect(graphOneX, graphOneY, graphWidth, graphHeight);
  rect(graphTwoX, graphTwoY, graphWidth, graphHeight);
  stroke(255);
  strokeWeight(0);
  line(graphOneX+1, graphOneY+graphHeight/2, graphOneX+graphWidth-1, graphOneY+graphHeight/2);
  line(graphTwoX+1, graphTwoY+graphHeight/2, graphTwoX+graphWidth-1, graphTwoY+graphHeight/2);
  
  for(int i = 1; i < graphLength; i++) {
    leftSpeedValue[i-1] = leftSpeedValue[i];
    rightSpeedValue[i-1] = rightSpeedValue[i];
  }
  
  println();
  println(leftSpeed);
  println(rightSpeed);
  
  leftSpeedValue[graphLength-1] = map((float)leftSpeed, -2000, 2000, -graphHeight/2, graphHeight/2);
  rightSpeedValue[graphLength-1] = map((float)rightSpeed, -2000, 2000, -graphHeight/2, graphHeight/2);

  stroke(60, 3, 255);
  strokeWeight(3);

  for(int i=1; i<graphWidth; i++) {
    point(graphOneX+i, graphOneY+graphHeight/2-(int)leftSpeedValue[graphLength-graphWidth+i]);
    point(graphTwoX+i, graphTwoY+graphHeight/2-(int)rightSpeedValue[graphLength-graphWidth+i]);
  }
  
}

boolean overCircle(int x, int y, int diameter) {
  float disX = x - mouseX;
  float disY = y - mouseY;
  if (sqrt(sq(disX) + sq(disY)) < diameter/2 ) {
    return true;
  } else {
    return false;
  }
}

void checkOver() {
  if (overCircle(leftX, leftY, diameter)) {
    leftOver = true;
  } else if (overCircle(middleX, middleY, diameter)) {
    middleOver = true;
  } else if (overCircle(rightX, rightY, diameter)) {
    rightOver = true;
  } else if (overCircle(modeButtonX, modeButtonY, diameter)) {
    modeButtonOver = true;
  } else {
    leftOver = middleOver = rightOver = false;
  }
}

void save(String filename) {
  
  List<String> stringList = new ArrayList();
  String line;
  
  reader = createReader(filename);
  
  do {
    
    try {
      line = reader.readLine();
    } catch (IOException e) {
      e.printStackTrace();
      line = null;
    }
    
    if (line != null) {
      stringList.add(line);
    }
    
  } while (line != null);
  
  writer = createWriter(filename);
  
  for (int i = 0; i < stringList.size(); i++) {
    writer.println(stringList.get(i));
  }
  stringList.clear();
  
  writer.print("{");
  writer.print(regionArray[0]);
  for (int i=1; i<regionSize; i++) {
    writer.print(", ");
    writer.print(regionArray[i]);
  }
  writer.println("}");
  writer.println(",");
  
  writer.flush();
  writer.close();
  
}

void keyPressed() {
  
  if (key == 'g') {
    if (leftOver) {
      save("leftData.txt");
    } else if (middleOver) {
      save("middleData.txt");
    } else if  (rightOver) {
      save("rightData.txt");
    }
  } else if (key == 'w') {
    myPort.write('w');
  } else if (key == 's') {
    myPort.write('s');
  } else if (key == 'a') {
    myPort.write('a');
  } else if (key == 'd') {
    myPort.write('d');
  }
  
}

void keyReleased() {
  
  if (key == 'w') {
    myPort.write('W');
  } else if (key == 's') {
    myPort.write('S');
  } else if (key == 'a') {
    myPort.write('A');
  } else if (key == 'd') {
    myPort.write('D');
  }
  
}

void mousePressed() {
  
  if (modeButtonOver) {
    
    overviewMode = !overviewMode;
    background(#04001F);
    
    if (overviewMode) {
      
      graphWidth = 400;
      graphOneX = 100;
      graphOneY = 300;
      graphTwoX = 600;
      graphTwoY = 300;
      
      fill(#898989);
      noStroke();
      rect(imageX, imageY, globalWidth*pixelSide, globalHeight*pixelSide);
      rect(boundaryX, boundaryY, globalWidth*pixelSide, globalHeight*pixelSide);
      rect(regionX, regionY, globalWidth*pixelSide, globalHeight*pixelSide);
      
      fill(#404040);
      rect(graphOneX, graphOneY, graphWidth, graphHeight);
      
      fill(0);
      ellipse(leftX, leftY, diameter, diameter);
      ellipse(middleX, middleY, diameter, diameter);
      ellipse(rightX, rightY, diameter, diameter);
      
    } else {
      
      graphWidth = 800;
      graphOneX = 100;
      graphOneY = 50;
      graphTwoX = 100;
      graphTwoY = 350;
      
    }
    
    fill(#6F0000);
    noStroke();
    ellipse(modeButtonX, modeButtonY, diameter, diameter);
    
  }
  
}

void setup() {
  
  printArray(Serial.list());
  myPort = new Serial(this, Serial.list()[6], 115200);
  size(1150, 650);
  background(#04001F);
  arrayPosX = 0;
  arrayPosY = 0;
  
  for (int y=0; y<globalHeight; y++) {
    for (int x=0; x<globalWidth; x++) {
      pixelArray[y][x] = false;
    }
  }
  
  leftSpeedValue = new double[graphLength];
  rightSpeedValue = new double[graphLength];
  for(int i = 0; i < graphWidth; i++) {
    leftSpeedValue[i] = 0;
    rightSpeedValue[i] = 0;
  }
  
  fill(#898989);
  noStroke();
  rect(imageX, imageY, globalWidth*pixelSide, globalHeight*pixelSide);
  rect(boundaryX, boundaryY, globalWidth*pixelSide, globalHeight*pixelSide);
  rect(regionX, regionY, globalWidth*pixelSide, globalHeight*pixelSide);
  
  fill(#404040);
  rect(graphOneX, graphOneY, graphWidth, graphHeight);
  
  fill(0);
  ellipse(leftX, leftY, diameter, diameter);
  ellipse(middleX, middleY, diameter, diameter);
  ellipse(rightX, rightY, diameter, diameter);
  fill(#6F0000);
  ellipse(modeButtonX, modeButtonY, diameter, diameter);
  

}

void draw() {
  
  if (myPort.available() > 0) {
    
    int inputInt = myPort.read();
    
    if (inputInt == 170) {
      
      int i = 0;
      arrayPosX = 0;
      arrayPosY = 0;
      
      while (i < globalWidth*globalHeight/8) {
        
        print('.');
        
        if (myPort.available() > 0) {
          inputInt = myPort.read();
          getImage(inputInt);
          i++;
        }
      
      }
      
      if (overviewMode) {
        outputImage();
        getBoundary();
        outputBoundary();
        getRegion();
        outputRegion();
        turningResult();
      }
      delay(1);
      
    }
    if (inputInt == 171) {
      
      String inputString;
      int i = 0;
      
      while (i < 2) {
        
        print(',');
        
        inputString = myPort.readStringUntil('\n');
        inputString = inputString.replaceAll("[^0-9]", "");
        
        if (inputString != null) {
          if (i == 0) {
            leftSpeed = Double.parseDouble(inputString);
            println(leftSpeed);
          } else if (i == 1) {
            rightSpeed = Double.parseDouble(inputString);
            println(rightSpeed);
          }
          i++;
        }
        
      }
      
    }
  
  }
  
  checkOver();  
  plotGraph();
  
}
